<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custom Shape Hole Calculator</title>
  <style>
    body { margin: 0; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
    #ui { width: 95%; max-width: 700px; background: #fff; padding: 15px; margin-top: 10px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    textarea, input, button { width: 100%; margin-top: 10px; box-sizing: border-box; font-size: 1em; }
    canvas.visual { width: 95vw; max-width: 700px; height: auto; margin: 10px 0; border: 1px solid #ccc; }
    canvas#hiddenCanvas { display: none; }
    h3 { margin: 0 0 10px 0; }
  </style>
</head>
<body>
<div id="ui">
  <h3>Upload Shape Image</h3>
  <input type="file" id="imgInput" accept="image/*">
  <button onclick="processImage()">Generate</button>
  <p>Plate A:</p>
  <textarea id="plateA" rows="6"></textarea>
  <p>Plate B:</p>
  <textarea id="plateB" rows="6"></textarea>
</div>
<canvas id="hiddenCanvas"></canvas>
<canvas id="previewCanvasA" class="visual" width="700" height="700"></canvas>
<canvas id="previewCanvasB" class="visual" width="700" height="700"></canvas>
<canvas id="connectionCanvas" class="visual" width="700" height="700"></canvas>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
  const plateSize = 300;
  const gap = 100;
  const resolution = 100;
  const holeSpacing = plateSize / resolution;

  const plateAholes = [];
  const plateBholes = [];

  function processImage() {
    const fileInput = document.getElementById("imgInput");
    if (!fileInput.files || fileInput.files.length === 0) {
      alert("Please upload an image.");
      return;
    }

    const file = fileInput.files[0];
    const reader = new FileReader();

    reader.onload = function(e) {
      const img = new Image();
      img.onload = function() {
        const hiddenCanvas = document.getElementById("hiddenCanvas");
        const hiddenCtx = hiddenCanvas.getContext("2d");
        hiddenCanvas.width = resolution;
        hiddenCanvas.height = resolution;
        hiddenCtx.drawImage(img, 0, 0, resolution, resolution);
        const imageData = hiddenCtx.getImageData(0, 0, resolution, resolution).data;

        plateAholes.length = 0;
        plateBholes.length = 0;

        const viewer = new THREE.Vector3(0, 0, 500);
        const plateAZ = 0;
        const plateBZ = gap;

        const previewCtxA = document.getElementById("previewCanvasA").getContext("2d");
        const previewCtxB = document.getElementById("previewCanvasB").getContext("2d");
        const connectionCtx = document.getElementById("connectionCanvas").getContext("2d");

        previewCtxA.clearRect(0, 0, 700, 700);
        previewCtxB.clearRect(0, 0, 700, 700);
        connectionCtx.clearRect(0, 0, 700, 700);

        previewCtxA.fillStyle = "black";
        previewCtxB.fillStyle = "black";
        connectionCtx.strokeStyle = "#444";
        connectionCtx.lineWidth = 0.5;

        for (let i = 0; i < resolution; i++) {
          for (let j = 0; j < resolution; j++) {
            const index = (j * resolution + i) * 4;
            const r = imageData[index];
            const g = imageData[index + 1];
            const b = imageData[index + 2];
            const brightness = (r + g + b) / 3;

            if (brightness < 128) {
              const px = (i - resolution / 2) * holeSpacing;
              const py = (j - resolution / 2) * holeSpacing;

              const target = new THREE.Vector3(px, py, (plateAZ + plateBZ) / 2);
              const dir = target.clone().sub(viewer).normalize();

              const tA = (plateAZ - viewer.z) / dir.z;
              const tB = (plateBZ - viewer.z) / dir.z;

              const pointA = viewer.clone().add(dir.clone().multiplyScalar(tA));
              const pointB = viewer.clone().add(dir.clone().multiplyScalar(tB));

              plateAholes.push(`${pointA.x.toFixed(1)}, ${pointA.y.toFixed(1)}`);
              plateBholes.push(`${pointB.x.toFixed(1)}, ${pointB.y.toFixed(1)}`);

              const canvasXA = pointA.x + plateSize / 2;
              const canvasYA = pointA.y + plateSize / 2;
              const canvasXB = pointB.x + plateSize / 2;
              const canvasYB = pointB.y + plateSize / 2;

              previewCtxA.beginPath();
              previewCtxA.arc(canvasXA * 2.33, canvasYA * 2.33, 2, 0, 2 * Math.PI);
              previewCtxA.fill();

              previewCtxB.beginPath();
              previewCtxB.arc(canvasXB * 2.33, canvasYB * 2.33, 2, 0, 2 * Math.PI);
              previewCtxB.fill();

              connectionCtx.beginPath();
              connectionCtx.moveTo(canvasXA * 2.33, canvasYA * 2.33);
              connectionCtx.lineTo(canvasXB * 2.33, canvasYB * 2.33);
              connectionCtx.stroke();
            }
          }
        }

        document.getElementById("plateA").value = plateAholes.join("\n");
        document.getElementById("plateB").value = plateBholes.join("\n");
      };
      img.src = e.target.result;
    };

    reader.readAsDataURL(file);
  }
</script>
</body>
</html>
